Здравствуйте!

Вместо введения: мне очень не нравится DLL и нравится, как сделаны миграции в http://rubyonrails.org/. Посему я задался целью сделать их аналог для .NET. Вот что получилось.

Миграции пишутся в .mdl-файле. Синтаксис -- помесь Python (блоки выделяются отступами) и Ruby. Поддерживаемые операции - add table, alter table, remove table, add column, alter column, remove column, add index, remove index, add reference, remove reference.

Пример MDL-файла:

migration "Blog" revision => 1:
    type-aliases:
        type-alias N type => String, length => 200, nullable => false, default => ""

    defaults:
        default-primary-key ID type => Int32, nullable => false, identity => true

    version 20090226100407:
        add table Author: /* Primary Key вставляется автоматически */
            FirstName type => N /* Здесь add column можно не указывать */
            LastName type => N
            EmailAddress type => N, unique => true /* "unique => true" приведет к автоматическому созданию индекса UQ_EmailAddress */
            Login type => N, unique => true
            Password type => Binary, length => 64, nullable => true
            
            index UQ_LoginEmailAddress unique => true, columns => [[Login, asc], EmailAddress]

        add table Tag:
            Name type => N

        add table Blog:
            Name type => N
            Description type => String, nullable => false

        add table BlogPost:
            Title type => N
            Slug type => N
            BlogID references => Blog /* Тип выводится автоматически; так же создается FK */
            AuthorID: 
                reference pk-table => Author /* "add" в "add reference" тоже можно опустить */

        add table BlogPostTagJunction primary-key => false: /* PK тут не подставляется */
            BlogPostID references => BlogPost
            TagID references => Tag

    version 20090226100408:
        add table BlogPostComment:
            BlogPostID references => BlogPost
            AuthorEmailAddress type => N
            Content type => String, nullable => false
            
Структура, дуюмаю, очевидна: корневой блок "migration", потом несколько дополнительных и опциональных (здесь -- "type-aliases" и "defaults") и основные блоки "version", которые и содержат инструкции по доведению схемы БД до кондиции. Номер версии -- целое число, влезающее в Int64. Почти все войства элементов я привел в примере, есть одно замечание: допустимые значения для свойства type -- члены стандартного перечисления System.Data.DbType.

Каждый блок отделяется отступом, а предшествющая блоку строка должна оканчиваться на ":".

Я надеюсь, синтаксис понятен и очевиден, но если будут вопросы -- буду рад ответить.

Работает это все следующим образом.

Есть консольное приложение - wizardby.exe. Вызывается так:

wizardby <команда> [<версия-или-шаг>] [/m(dl):<имя-mdl-файла>] [/c(onnection):<строка-соединения>] [/p(latform):<платформа>]

Как видно, все, кроме <команды> -- необязательные аргументы (за редким исключением).

Команды поддерживаются следующие:
d(owngrade) - откатывает БД до "нулевой версии"
u(pgrade) - применяет все миграции
re(do) - заново применяет последнюю миграцию. Если указать парамерт <версия-или-шаг>, то именно столько миграций будет применено заново.
ro(llback) - откатить последнюю (или <версия-или-шаг>) миграцию.
m(igrate) - привести БД к версии <версия-или-шаг> -- неважно, вверх или вниз.
g(enerate) - добавляет к указанному MDL-файлу блок "version" с номером версии, равным текущей дате

Если опущен параметр "/m(dl)", то будет использован первый найденный MDL-файл из рабочей директории.

Параметры "/c(onnection)" и "/p(latform)" можно не указывать, если воспольоваться файлом database.wdl

deployment:
    environment development
        platform			=> sqlserver 
        host				=> "(local)\sqlexpress"
        database			=> dev
        integrated-security	=> true